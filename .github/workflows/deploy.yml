name: Deploy to Cloud Run

permissions:
  contents: read
  security-events: write
  actions: read

on:
  push:
    branches: [ staging, develop, main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      db_instance_name:
        description: 'Cloud SQL instance name (override, e.g., orderly-db-v2)'
        required: false
        type: string
      services:
        description: 'Services to deploy (comma-separated, leave empty for all)'
        required: false
        type: string
      force_backend_redeploy:
        description: 'Force redeploy backend services (deploy ALL or selected)'
        required: false
        default: false
        type: boolean
      service_suffix:
        description: 'Optional service name suffix (e.g., -staging-v2)'
        required: false
        type: string
      use_v2_backends:
        description: 'Set USE_V2_BACKENDS=true on API Gateway'
        required: false
        default: false
        type: boolean
      use_service_accounts:
        description: 'Deploy each service with its own service account'
        required: false
        default: false
        type: boolean
      ref_name:
        description: 'Git ref/branch to deploy from (e.g., staging, develop, main)'
        required: false
        type: string
      force_frontend_redeploy:
        description: 'Force redeploy frontend even if no code changes'
        required: false
        default: false
        type: boolean
      enable_smoke_correlation:
        description: 'Capture X-Correlation-ID for smoke endpoints in summary'
        required: false
        default: false
        type: boolean

env:
  GOOGLE_CLOUD_PROJECT: ${{ secrets.GCP_PROJECT_ID || secrets.GOOGLE_CLOUD_PROJECT || 'orderly-472413' }}
  GOOGLE_CLOUD_REGION: asia-east1
  REGISTRY: asia-east1-docker.pkg.dev

jobs:
  determine-environment:
    name: Determine Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      deploy: ${{ steps.env.outputs.deploy }}
      force_frontend: ${{ steps.env.outputs.force_frontend }}
      force_backend: ${{ steps.env.outputs.force_backend }}
      ref_name: ${{ steps.env.outputs.ref_name }}
      context_ok: ${{ steps.env.outputs.context_ok }}
      db_instance_name: ${{ steps.db.outputs.db_instance_name }}
      service_suffix: ${{ steps.flags.outputs.service_suffix }}
      use_v2_backends: ${{ steps.flags.outputs.use_v2_backends }}
      use_service_accounts: ${{ steps.flags.outputs.use_service_accounts }}
    steps:
      - name: Determine deployment environment
        id: env
        run: |
          # Resolve ref/branch name
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.ref_name }}" ]; then
            REF_NAME="${{ github.event.inputs.ref_name }}"
          else
            REF_NAME="${GITHUB_REF_NAME}"
          fi
          echo "ref_name=$REF_NAME" >> $GITHUB_OUTPUT

          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "deploy=true" >> $GITHUB_OUTPUT
            echo "force_frontend=${{ github.event.inputs.force_frontend_redeploy }}" >> $GITHUB_OUTPUT
            echo "force_backend=${{ github.event.inputs.force_backend_redeploy }}" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "deploy=true" >> $GITHUB_OUTPUT
            echo "force_frontend=false" >> $GITHUB_OUTPUT
            echo "force_backend=false" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/develop" ]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "deploy=true" >> $GITHUB_OUTPUT
            echo "force_frontend=false" >> $GITHUB_OUTPUT
            echo "force_backend=false" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/staging" ]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "deploy=true" >> $GITHUB_OUTPUT
            echo "force_frontend=false" >> $GITHUB_OUTPUT
            echo "force_backend=false" >> $GITHUB_OUTPUT
          else
            echo "environment=none" >> $GITHUB_OUTPUT
            echo "deploy=false" >> $GITHUB_OUTPUT
            echo "force_frontend=false" >> $GITHUB_OUTPUT
            echo "force_backend=false" >> $GITHUB_OUTPUT
          fi

          # Context guardrails: ensure env and ref are consistent
          ENV_RESOLVED=$(grep '^environment=' "$GITHUB_OUTPUT" | tail -n1 | cut -d'=' -f2)
          CONTEXT_OK=true
          if [ "$ENV_RESOLVED" = "staging" ] && [ "$REF_NAME" = "main" ]; then
            echo "‚ö†Ô∏è Ref 'main' with environment=staging is not allowed." >&2
            CONTEXT_OK=false
          fi
          if [ "$ENV_RESOLVED" = "production" ] && [ "$REF_NAME" != "main" ]; then
            echo "‚ö†Ô∏è Production deployments must use ref 'main' (got '$REF_NAME')." >&2
            CONTEXT_OK=false
          fi
          echo "context_ok=$CONTEXT_OK" >> $GITHUB_OUTPUT

      - name: Print context
        run: |
          echo "Using environment: ${{ steps.env.outputs.environment }}"
          echo "Using ref: ${{ steps.env.outputs.ref_name }} (sha: $GITHUB_SHA)"

      - name: Resolve workflow flags
        id: flags
        run: |
          SUFFIX=""
          USE_V2=false
          USE_SA=false
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            SUFFIX="${{ github.event.inputs.service_suffix }}"
            [ "${{ github.event.inputs.use_v2_backends }}" = "true" ] && USE_V2=true
            [ "${{ github.event.inputs.use_service_accounts }}" = "true" ] && USE_SA=true
          fi
          echo "service_suffix=$SUFFIX" >> $GITHUB_OUTPUT
          echo "use_v2_backends=$USE_V2" >> $GITHUB_OUTPUT
          echo "use_service_accounts=$USE_SA" >> $GITHUB_OUTPUT

      - name: Resolve DB instance name
        id: db
        run: |
          # Priority 1: manual override via workflow_dispatch input
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.db_instance_name }}" ]; then
            echo "db_instance_name=${{ github.event.inputs.db_instance_name }}" >> $GITHUB_OUTPUT
            exit 0
          fi
          # Priority 2: environment-based default (staging -> orderly-db-v2, production -> orderly-db)
          if [ "${{ steps.env.outputs.environment }}" = "staging" ]; then
            echo "db_instance_name=orderly-db-v2" >> $GITHUB_OUTPUT
          else
            echo "db_instance_name=orderly-db" >> $GITHUB_OUTPUT
          fi

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: determine-environment
    if: needs.determine-environment.outputs.deploy == 'true'
    steps:
      - uses: actions/checkout@v4
      
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          format: 'sarif'
          output: 'trivy-results.sarif'
      
      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        continue-on-error: true
        with:
          sarif_file: 'trivy-results.sarif'

  detect-changes:
    name: Detect Changed Services
    runs-on: ubuntu-latest
    needs: [determine-environment]
    if: needs.determine-environment.outputs.deploy == 'true'
    outputs:
      changed-services: ${{ steps.changes.outputs.services }}
      has-infrastructure-changes: ${{ steps.changes.outputs.infrastructure }}
      has-frontend-changes: ${{ steps.changes.outputs.frontend }}
      all-services: ${{ steps.changes.outputs.all_services }}
      requested-services: ${{ steps.changes.outputs.requested_services }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Get full history for proper diff
      
      - name: Detect changed services and components
        id: changes
        run: |
          # Define all available services
          ALL_SERVICES='["api-gateway-fastapi","user-service-fastapi","order-service-fastapi","product-service-fastapi","acceptance-service-fastapi","notification-service-fastapi","customer-hierarchy-service-fastapi","supplier-service-fastapi"]'
          echo "all_services=$ALL_SERVICES" >> $GITHUB_OUTPUT
          
          # If manual dispatch with selected services or forced backend, honor it
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.services }}" ]; then
            IFS=',' read -ra REQ <<< "${{ github.event.inputs.services }}"
            # Build JSON array from requested services
            req_json=$(printf '['; first=true; for s in "${REQ[@]}"; do s_trim=$(echo "$s" | xargs); [ -z "$s_trim" ] && continue; $first || printf ','; printf '"%s"' "$s_trim"; first=false; done; printf ']')
            echo "services=$req_json" >> $GITHUB_OUTPUT
            echo "requested_services=$req_json" >> $GITHUB_OUTPUT
            echo "infrastructure=true" >> $GITHUB_OUTPUT
            echo "frontend=true" >> $GITHUB_OUTPUT
            echo "üì¶ Manual requested services: $req_json"
            exit 0
          fi

          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ needs.determine-environment.outputs.force_backend }}" = "true" ]; then
            echo "services=$ALL_SERVICES" >> $GITHUB_OUTPUT
            echo "requested_services=$ALL_SERVICES" >> $GITHUB_OUTPUT
            echo "infrastructure=true" >> $GITHUB_OUTPUT
            echo "frontend=true" >> $GITHUB_OUTPUT
            echo "üì¶ Forced backend redeploy - deploying ALL services"
            exit 0
          fi

          # Get changed files (compare with previous commit or main if first push)
          if [ "${{ github.event_name }}" = "push" ] && [ -n "$(git rev-parse --verify HEAD~1 2>/dev/null)" ]; then
            changed_files=$(git diff --name-only HEAD~1 HEAD)
          else
            # First commit or manual trigger - deploy all services
            echo "services=$ALL_SERVICES" >> $GITHUB_OUTPUT
            echo "infrastructure=true" >> $GITHUB_OUTPUT
            echo "frontend=true" >> $GITHUB_OUTPUT
            echo "üì¶ Manual trigger or first commit - deploying all services"
            exit 0
          fi
          
          echo "üîç Changed files:"
          echo "$changed_files"
          
          # Check for infrastructure changes
          infrastructure_changed=false
          if echo "$changed_files" | grep -E "(infrastructure/|\.github/workflows/|scripts/deploy|docker-compose)" > /dev/null; then
            infrastructure_changed=true
          fi
          echo "infrastructure=$infrastructure_changed" >> $GITHUB_OUTPUT
          
          # Check for frontend changes
          frontend_changed=false
          echo "üîç Testing frontend pattern match..."
          if echo "$changed_files" | grep -E "(app/|components/|lib/|shared/types/|contexts/|hooks/|stores/|types/|public/|package\.json|package-lock\.json|next\.config\.(js|mjs)|instrumentation\.(ts|js)|middleware\.(ts|js)|tailwind\.config\.(ts|js)|tsconfig\.json|postcss\.config\.(js|mjs)|Dockerfile\.frontend|\.env\.example)"; then
            frontend_changed=true
            echo "‚úÖ Frontend changes detected!"
          else
            echo "‚ùå No frontend changes detected"
          fi
          echo "frontend=$frontend_changed" >> $GITHUB_OUTPUT
          
          # Detect changed services
          changed_services=()
          for service in api-gateway-fastapi user-service-fastapi order-service-fastapi product-service-fastapi acceptance-service-fastapi notification-service-fastapi customer-hierarchy-service-fastapi supplier-service-fastapi; do
            if echo "$changed_files" | grep -q "backend/$service/"; then
              changed_services+=("\"$service\"")
              echo "üì¶ Detected changes in: $service"
            fi
          done
          
          # Check for shared library changes that affect all services
          if echo "$changed_files" | grep -E "(backend/libs/|shared/types/)" > /dev/null; then
            echo "üìö Shared library changes detected - rebuilding all services"
            changed_services=("\"api-gateway-fastapi\"" "\"user-service-fastapi\"" "\"order-service-fastapi\"" "\"product-service-fastapi\"" "\"acceptance-service-fastapi\"" "\"notification-service-fastapi\"" "\"customer-hierarchy-service-fastapi\"" "\"supplier-service-fastapi\"")
          fi
          
          # Format as JSON array
          if [ ${#changed_services[@]} -eq 0 ]; then
            echo "services=[]" >> $GITHUB_OUTPUT
            echo "üö´ No service changes detected"
          else
            services_json="[$(IFS=,; echo "${changed_services[*]}")]"
            echo "services=$services_json" >> $GITHUB_OUTPUT
            echo "‚úÖ Services to deploy: $services_json"
          fi

  setup-registry:
    name: Setup Artifact Registry
    runs-on: ubuntu-latest
    needs: [determine-environment, detect-changes]
    if: needs.determine-environment.outputs.deploy == 'true' && needs.determine-environment.outputs.context_ok == 'true' && (needs.detect-changes.outputs.changed-services != '[]' || needs.detect-changes.outputs.has-infrastructure-changes == 'true' || needs.detect-changes.outputs.has-frontend-changes == 'true')
    steps:
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
      
      - name: Create Artifact Registry repository
        run: |
          # Create repository if it doesn't exist (single job to avoid race condition)
          gcloud artifacts repositories describe orderly \
            --location=asia-east1 \
            --format="value(name)" || \
          gcloud artifacts repositories create orderly \
            --repository-format=docker \
            --location=asia-east1 \
            --description="Orderly microservices container registry"
          
          echo "‚úÖ Artifact Registry repository ready"

  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest
    needs: [determine-environment, detect-changes, setup-registry]
    if: needs.determine-environment.outputs.deploy == 'true' && needs.determine-environment.outputs.context_ok == 'true' && (needs.detect-changes.outputs.changed-services != '[]' || github.event.inputs.services != '' || needs.determine-environment.outputs.force_backend == 'true')
    
    strategy:
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.requested-services != '' && needs.detect-changes.outputs.requested-services || needs.detect-changes.outputs.changed-services) }}
      fail-fast: false
      max-parallel: 8  # Increased from 3 to 8 for faster parallel builds

    steps:
      - uses: actions/checkout@v4
      
      # Multi-layer caching setup
      - name: Set up Docker Buildx with cache
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: image=moby/buildkit:latest
          buildkitd-flags: --allow-insecure-entitlement security.insecure
      
      - name: Setup pip cache
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: pip-${{ matrix.service }}-${{ hashFiles(format('backend/{0}/requirements.txt', matrix.service)) }}
          restore-keys: |
            pip-${{ matrix.service }}-
            pip-
      
      - name: Setup build cache
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache-${{ matrix.service }}
          key: buildx-${{ matrix.service }}-${{ github.sha }}
          restore-keys: |
            buildx-${{ matrix.service }}-
            buildx-
      
      - name: Check if service exists
        id: check-service
        run: |
          SERVICE_DIR="backend/${{ matrix.service }}"
          if [ -d "$SERVICE_DIR" ] && [ -f "$SERVICE_DIR/Dockerfile" ]; then
            echo "‚úÖ Found service at $SERVICE_DIR"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Service not found at $SERVICE_DIR"
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Debug: Listing actual FastAPI services:"
            ls -la backend/ | grep fastapi || echo "No FastAPI services found"
          fi
      
      - name: Authenticate to Google Cloud
        if: steps.check-service.outputs.exists == 'true'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        if: steps.check-service.outputs.exists == 'true'
        uses: google-github-actions/setup-gcloud@v2
      
      - name: Configure Docker to use gcloud as credential helper
        if: steps.check-service.outputs.exists == 'true'
        run: gcloud auth configure-docker asia-east1-docker.pkg.dev
      
      - name: Build and push Docker image with enhanced caching
        if: steps.check-service.outputs.exists == 'true'
        uses: docker/build-push-action@v5
        env:
          IMAGE_TAG: ${{ github.sha }}
          ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
        with:
          # Build from backend root so shared 'libs' is available to all service Dockerfiles
          context: backend
          file: backend/${{ matrix.service }}/Dockerfile
          push: true
          platforms: linux/amd64  # Specify platform for consistency
          tags: |
            ${{ env.REGISTRY }}/${{ env.GOOGLE_CLOUD_PROJECT }}/orderly/orderly-${{ matrix.service }}:latest
            ${{ env.REGISTRY }}/${{ env.GOOGLE_CLOUD_PROJECT }}/orderly/orderly-${{ matrix.service }}:${{ github.sha }}
            ${{ env.REGISTRY }}/${{ env.GOOGLE_CLOUD_PROJECT }}/orderly/orderly-${{ matrix.service }}:${{ needs.determine-environment.outputs.environment }}
          # Enhanced multi-layer caching
          cache-from: |
            type=local,src=/tmp/.buildx-cache-${{ matrix.service }}
            type=registry,ref=${{ env.REGISTRY }}/${{ env.GOOGLE_CLOUD_PROJECT }}/orderly/cache-${{ matrix.service }}:latest
            type=registry,ref=${{ env.REGISTRY }}/${{ env.GOOGLE_CLOUD_PROJECT }}/orderly/cache-${{ matrix.service }}:${{ needs.determine-environment.outputs.environment }}
          cache-to: |
            type=local,dest=/tmp/.buildx-cache-${{ matrix.service }}-new,mode=max
            type=registry,ref=${{ env.REGISTRY }}/${{ env.GOOGLE_CLOUD_PROJECT }}/orderly/cache-${{ matrix.service }}:latest,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1
            SERVICE_NAME=${{ matrix.service }}
      
      - name: Optimize cache
        if: steps.check-service.outputs.exists == 'true'
        run: |
          # Move cache to optimize for next build
          rm -rf /tmp/.buildx-cache-${{ matrix.service }}
          mv /tmp/.buildx-cache-${{ matrix.service }}-new /tmp/.buildx-cache-${{ matrix.service }} || true

  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [determine-environment, setup-registry]
    if: needs.determine-environment.outputs.deploy == 'true' && needs.determine-environment.outputs.context_ok == 'true'
    environment: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
      
      - name: Deploy infrastructure
        env:
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          JWT_REFRESH_SECRET: ${{ secrets.JWT_REFRESH_SECRET }}
          ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
          DB_INSTANCE_NAME: ${{ needs.determine-environment.outputs.db_instance_name }}
        run: |
          chmod +x scripts/deploy-cloud-run.sh
          scripts/deploy-cloud-run.sh infra

  deploy-services:
    name: Deploy Services
    runs-on: ubuntu-latest
    # Ensure images are built and pushed before deploying
    needs: [determine-environment, detect-changes, setup-registry, build-and-push, deploy-infrastructure]
    if: needs.determine-environment.outputs.deploy == 'true' && needs.determine-environment.outputs.context_ok == 'true' && (needs.detect-changes.outputs.changed-services != '[]' || needs.detect-changes.outputs.requested-services != '' || github.event.inputs.services != '' || needs.determine-environment.outputs.force_backend == 'true')
    environment: ${{ needs.determine-environment.outputs.environment }}
    
    strategy:
      matrix:
        # Match the same selection used by build-and-push so deploy waits on the exact services built
        service: ${{ fromJson(needs.detect-changes.outputs.requested-services != '' && needs.detect-changes.outputs.requested-services || needs.detect-changes.outputs.changed-services) }}
      fail-fast: false
      max-parallel: 8  # Increased from 3 to 8 for faster parallel deployments

    steps:
      - uses: actions/checkout@v4
      
      - name: Check if service should be deployed
        id: check-deploy
        run: |
          # Check if specific services were requested
          if [ -n "${{ github.event.inputs.services }}" ]; then
            if echo "${{ github.event.inputs.services }}" | grep -q "${{ matrix.service }}"; then
              echo "deploy=true" >> $GITHUB_OUTPUT
            else
              echo "deploy=false" >> $GITHUB_OUTPUT
            fi
          else
            # Deploy all services if none specified
            if [ -d "backend/${{ matrix.service }}" ]; then
              echo "deploy=true" >> $GITHUB_OUTPUT
            else
              echo "deploy=false" >> $GITHUB_OUTPUT
            fi
          fi
      
      - name: Authenticate to Google Cloud
        if: steps.check-deploy.outputs.deploy == 'true'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        if: steps.check-deploy.outputs.deploy == 'true'
        uses: google-github-actions/setup-gcloud@v2
      
      - name: Deploy ${{ matrix.service }}
        if: steps.check-deploy.outputs.deploy == 'true'
        env:
          IMAGE_TAG: ${{ github.sha }}
          ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          JWT_REFRESH_SECRET: ${{ secrets.JWT_REFRESH_SECRET }}
          DB_INSTANCE_NAME: ${{ needs.determine-environment.outputs.db_instance_name }}
          SERVICE_SUFFIX: ${{ needs.determine-environment.outputs.service_suffix }}
          USE_SERVICE_ACCOUNTS: ${{ needs.determine-environment.outputs.use_service_accounts }}
        run: |
          # Verify image exists before deploying (avoid race between push and deploy)
          IMAGE_URI="$REGISTRY/$GOOGLE_CLOUD_PROJECT/orderly/orderly-${{ matrix.service }}:$IMAGE_TAG"
          echo "üîé Verifying image exists: $IMAGE_URI"
          for i in {1..24}; do
            if gcloud artifacts docker images describe "$IMAGE_URI" --project="$GOOGLE_CLOUD_PROJECT" >/dev/null 2>&1; then
              echo "‚úÖ Image found in Artifact Registry"
              break
            fi
            echo "‚è≥ Image not found yet, waiting... ($i/24)"
            sleep 5
          done
          # Final verification
          gcloud artifacts docker images describe "$IMAGE_URI" --project="$GOOGLE_CLOUD_PROJECT"

          # Validate service name
          case "${{ matrix.service }}" in
            "api-gateway-fastapi"|"user-service-fastapi"|"order-service-fastapi"|"product-service-fastapi"|"acceptance-service-fastapi"|"notification-service-fastapi"|"customer-hierarchy-service-fastapi"|"supplier-service-fastapi") 
              echo "Deploying service: ${{ matrix.service }}"
              ;;
            *) echo "Unknown service: ${{ matrix.service }}"; exit 1 ;;
          esac
          
          # Get database connection name
          DB_CONNECTION_NAME=$(gcloud sql instances describe "$DB_INSTANCE_NAME" \
            --format="value(connectionName)" --project="$GOOGLE_CLOUD_PROJECT")
          
          # Get Redis IP
          REDIS_HOST=$(gcloud redis instances describe orderly-cache \
            --region="$GOOGLE_CLOUD_REGION" --format="value(host)" --project="$GOOGLE_CLOUD_PROJECT")
          
          # Set resource limits based on environment
          if [ "$ENVIRONMENT" = "production" ]; then
            MEMORY="1Gi"
            CPU="2"
            MIN_INSTANCES="1"
            MAX_INSTANCES="20"
            CONCURRENCY="80"
          else
            MEMORY="512Mi"
            CPU="1"
            MIN_INSTANCES="0"
            MAX_INSTANCES="10"
            CONCURRENCY="100"
          fi

          # Staging overrides for critical services to reduce cold starts
          if [ "$ENVIRONMENT" = "staging" ]; then
            if [ "${{ matrix.service }}" = "supplier-service-fastapi" ]; then
              echo "üîß Override: setting min-instances=1 for supplier-service-fastapi in staging"
              MIN_INSTANCES="1"
            fi
          fi
          
          # Deploy to Cloud Run
          SERVICE_NAME="orderly-${{ matrix.service }}-$ENVIRONMENT${SERVICE_SUFFIX}"

          # Optional per-service Service Account (map service names to SA IDs)
          SA_FLAG=""
          if [ "$USE_SERVICE_ACCOUNTS" = "true" ]; then
            case "${{ matrix.service }}" in
              "api-gateway-fastapi") SA_ID="orderly-apigw-fastapi" ;;
              "user-service-fastapi") SA_ID="orderly-user-fastapi" ;;
              "order-service-fastapi") SA_ID="orderly-order-fastapi" ;;
              "product-service-fastapi") SA_ID="orderly-product-fastapi" ;;
              "acceptance-service-fastapi") SA_ID="orderly-accept-fastapi" ;;
              "notification-service-fastapi") SA_ID="orderly-notify-fastapi" ;;
              "customer-hierarchy-service-fastapi") SA_ID="orderly-custhier-fastapi" ;;
              "supplier-service-fastapi") SA_ID="orderly-supplier-fastapi" ;;
              "billing-service-fastapi") SA_ID="orderly-billing-fastapi" ;;
              *) SA_ID="" ;;
            esac
            
            if [ -n "$SA_ID" ]; then
              SA_EMAIL="${SA_ID}@${GOOGLE_CLOUD_PROJECT}.iam.gserviceaccount.com"
              if gcloud iam service-accounts describe "$SA_EMAIL" --project="$GOOGLE_CLOUD_PROJECT" >/dev/null 2>&1; then
                SA_FLAG="--service-account=$SA_EMAIL"
                echo "üîê Using service account: $SA_EMAIL"
              else
                echo "‚ö†Ô∏è Service account not found: $SA_EMAIL (skip)"
              fi
            else
              echo "‚ö†Ô∏è No service account mapping for: ${{ matrix.service }}"
            fi
          fi

          gcloud run deploy "$SERVICE_NAME" \
            --image="$REGISTRY/$GOOGLE_CLOUD_PROJECT/orderly/orderly-${{ matrix.service }}:$IMAGE_TAG" \
            --platform=managed \
            --region="$GOOGLE_CLOUD_REGION" \
            --allow-unauthenticated \
            --memory="$MEMORY" \
            --cpu="$CPU" \
            --min-instances="$MIN_INSTANCES" \
            --max-instances="$MAX_INSTANCES" \
            --concurrency="$CONCURRENCY" \
            --timeout=300 \
            --set-env-vars="NODE_ENV=$ENVIRONMENT" \
            --set-env-vars="REDIS_HOST=$REDIS_HOST,REDIS_PORT=6379" \
            --set-env-vars="DATABASE_HOST=/cloudsql/$DB_CONNECTION_NAME,DATABASE_NAME=orderly,DATABASE_USER=orderly" \
            --set-secrets="POSTGRES_PASSWORD=postgres-password:latest" \
            --set-secrets="JWT_SECRET=jwt-secret:latest" \
            --set-secrets="JWT_REFRESH_SECRET=jwt-refresh-secret:latest" \
            --add-cloudsql-instances="$DB_CONNECTION_NAME" \
            $SA_FLAG \
            --project="$GOOGLE_CLOUD_PROJECT" \
            --labels="environment=$ENVIRONMENT,service=${{ matrix.service }},version=$IMAGE_TAG,git_ref=${{ needs.determine-environment.outputs.ref_name }},git_sha=$GITHUB_SHA"

          # Wait for the service /health to become available (max ~90s)
          SVC_URL=$(gcloud run services describe "$SERVICE_NAME" \
            --region="$GOOGLE_CLOUD_REGION" --format="value(status.url)" \
            --project="$GOOGLE_CLOUD_PROJECT")
          echo "‚è≥ Waiting for service ${{ matrix.service }} to be healthy at $SVC_URL/health"
          for i in {1..18}; do
            if curl -sf "$SVC_URL/health" --max-time 5 >/dev/null; then
              echo "‚úÖ ${{ matrix.service }} is healthy"
              break
            fi
            sleep 5
          done

  configure-routing:
    name: Configure Service Routing
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-infrastructure, deploy-services]
    if: needs.determine-environment.outputs.deploy == 'true' && needs.determine-environment.outputs.context_ok == 'true'
    environment: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
      
      - name: Configure API Gateway routing
        env:
          ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
          SERVICE_SUFFIX: ${{ needs.determine-environment.outputs.service_suffix }}
          USE_V2_BACKENDS: ${{ needs.determine-environment.outputs.use_v2_backends }}
        run: |
          # Get all service URLs
          declare -A service_urls
          for service in api-gateway-fastapi user-service-fastapi order-service-fastapi product-service-fastapi acceptance-service-fastapi notification-service-fastapi customer-hierarchy-service-fastapi supplier-service-fastapi; do
            url=$(gcloud run services describe "orderly-$service-$ENVIRONMENT${SERVICE_SUFFIX}" \
              --region="$GOOGLE_CLOUD_REGION" --format="value(status.url)" \
              --project="$GOOGLE_CLOUD_PROJECT" 2>/dev/null || echo "")
            if [ -n "$url" ]; then
              service_urls["$service"]="$url"
            fi
          done
          
          # Map Cloud Run service URLs to API Gateway expected env var names
          # FastAPI Gateway expects: USER_SERVICE_URL, ORDER_SERVICE_URL, PRODUCT_SERVICE_URL,
          # ACCEPTANCE_SERVICE_URL (note: must include '/acceptance' suffix), NOTIFICATION_SERVICE_URL,
          # CUSTOMER_HIERARCHY_SERVICE_URL, SUPPLIER_SERVICE_URL
          env_vars="NODE_ENV=$ENVIRONMENT,USE_V2_BACKENDS=$USE_V2_BACKENDS"
          if [ -n "${service_urls[user-service-fastapi]}" ]; then
            env_vars+=",USER_SERVICE_URL=${service_urls[user-service-fastapi]}"
          fi
          if [ -n "${service_urls[order-service-fastapi]}" ]; then
            env_vars+=",ORDER_SERVICE_URL=${service_urls[order-service-fastapi]}"
          fi
          if [ -n "${service_urls[product-service-fastapi]}" ]; then
            env_vars+=",PRODUCT_SERVICE_URL=${service_urls[product-service-fastapi]}"
          fi
          if [ -n "${service_urls[acceptance-service-fastapi]}" ]; then
            # acceptance service routes are under '/acceptance' on the service
            env_vars+=",ACCEPTANCE_SERVICE_URL=${service_urls[acceptance-service-fastapi]}/acceptance"
          fi
          if [ -n "${service_urls[notification-service-fastapi]}" ]; then
            env_vars+=",NOTIFICATION_SERVICE_URL=${service_urls[notification-service-fastapi]}"
          fi
          if [ -n "${service_urls[customer-hierarchy-service-fastapi]}" ]; then
            env_vars+=",CUSTOMER_HIERARCHY_SERVICE_URL=${service_urls[customer-hierarchy-service-fastapi]}"
          fi
          if [ -n "${service_urls[supplier-service-fastapi]}" ]; then
            env_vars+=",SUPPLIER_SERVICE_URL=${service_urls[supplier-service-fastapi]}"
          fi

          echo "Applying env vars to API Gateway: $env_vars (suffix='${SERVICE_SUFFIX}')"
          gcloud run services update "orderly-api-gateway-fastapi-$ENVIRONMENT${SERVICE_SUFFIX}" \
            --region="$GOOGLE_CLOUD_REGION" \
            --set-env-vars="$env_vars" \
            --labels="environment=$ENVIRONMENT,git_ref=${{ needs.determine-environment.outputs.ref_name }},git_sha=$GITHUB_SHA" \
            --project="$GOOGLE_CLOUD_PROJECT"

  deploy-frontend:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    needs: [determine-environment, detect-changes, deploy-infrastructure]
    if: needs.determine-environment.outputs.deploy == 'true' && needs.determine-environment.outputs.context_ok == 'true' && (needs.detect-changes.outputs.has-frontend-changes == 'true' || needs.determine-environment.outputs.force_frontend == 'true')
    steps:
      - uses: actions/checkout@v4
      
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Configure Docker for Artifact Registry
        run: |
          gcloud auth configure-docker asia-east1-docker.pkg.dev
        
      - name: Build and deploy frontend
        env:
          ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
          REGISTRY: ${{ env.REGISTRY }}
          GOOGLE_CLOUD_PROJECT: ${{ env.GOOGLE_CLOUD_PROJECT }}
          GOOGLE_CLOUD_REGION: ${{ env.GOOGLE_CLOUD_REGION }}
          SERVICE_SUFFIX: ${{ needs.determine-environment.outputs.service_suffix }}
        run: |
          echo "üöÄ Building and deploying frontend for $ENVIRONMENT"
          
          # Get API Gateway URL for frontend configuration
          BACKEND_URL=$(gcloud run services describe "orderly-api-gateway-fastapi-$ENVIRONMENT${SERVICE_SUFFIX}" \
            --region="$GOOGLE_CLOUD_REGION" --format="value(status.url)" \
            --project="$GOOGLE_CLOUD_PROJECT" 2>/dev/null || echo "")
          
          if [ -z "$BACKEND_URL" ]; then
            echo "‚ö†Ô∏è API Gateway not found, using placeholder URL"
            BACKEND_URL="https://orderly-api-gateway-fastapi-$ENVIRONMENT-placeholder.run.app"
          fi
          
          echo "üì° Backend URL for frontend: $BACKEND_URL"
          
          # Build frontend image (no build-time backend URL needed)
          docker buildx build \
            --platform linux/amd64 \
            --tag "$REGISTRY/$GOOGLE_CLOUD_PROJECT/orderly/orderly-frontend:$ENVIRONMENT-${{ github.sha }}" \
            --tag "$REGISTRY/$GOOGLE_CLOUD_PROJECT/orderly/orderly-frontend:$ENVIRONMENT-latest" \
            --push \
            -f Dockerfile.frontend \
            .
          
          # Deploy to Cloud Run with backend URL as runtime variable
          gcloud run deploy "orderly-frontend-$ENVIRONMENT${SERVICE_SUFFIX}" \
            --image="$REGISTRY/$GOOGLE_CLOUD_PROJECT/orderly/orderly-frontend:$ENVIRONMENT-${{ github.sha }}" \
            --region="$GOOGLE_CLOUD_REGION" \
            --platform=managed \
            --allow-unauthenticated \
            --set-env-vars="NODE_ENV=$ENVIRONMENT,ORDERLY_BACKEND_URL=$BACKEND_URL,BACKEND_URL=$BACKEND_URL,NEXT_PUBLIC_API_BASE_URL=$BACKEND_URL/api" \
            --memory=1Gi \
            --cpu=1 \
            --min-instances=0 \
            --max-instances=10 \
            --concurrency=100 \
            --port=8080 \
            --project="$GOOGLE_CLOUD_PROJECT" \
            --labels="environment=$ENVIRONMENT,git_ref=${{ needs.determine-environment.outputs.ref_name }},git_sha=$GITHUB_SHA"
          
          echo "‚úÖ Frontend deployed successfully with backend URL: $BACKEND_URL"

  update-frontend-env:
    name: Update Frontend Env Vars
    runs-on: ubuntu-latest
    needs: [determine-environment, configure-routing]
    if: needs.determine-environment.outputs.deploy == 'true' && needs.determine-environment.outputs.context_ok == 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Update frontend environment variables on Cloud Run
        env:
          ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
          GOOGLE_CLOUD_PROJECT: ${{ env.GOOGLE_CLOUD_PROJECT }}
          GOOGLE_CLOUD_REGION: ${{ env.GOOGLE_CLOUD_REGION }}
          SERVICE_SUFFIX: ${{ needs.determine-environment.outputs.service_suffix }}
        run: |
          echo "üîß Updating frontend env vars for $ENVIRONMENT"
          BACKEND_URL=$(gcloud run services describe "orderly-api-gateway-fastapi-$ENVIRONMENT${SERVICE_SUFFIX}" \
            --region="$GOOGLE_CLOUD_REGION" --format="value(status.url)" \
            --project="$GOOGLE_CLOUD_PROJECT" 2>/dev/null || echo "")
          if [ -z "$BACKEND_URL" ]; then
            echo "‚ö†Ô∏è API Gateway not found, using placeholder URL"
            BACKEND_URL="https://orderly-api-gateway-fastapi-$ENVIRONMENT-placeholder.run.app"
          fi
          echo "üì° Backend URL for frontend: $BACKEND_URL"
          gcloud run services update "orderly-frontend-$ENVIRONMENT${SERVICE_SUFFIX}" \
            --region="$GOOGLE_CLOUD_REGION" \
            --set-env-vars="NODE_ENV=$ENVIRONMENT,ORDERLY_BACKEND_URL=$BACKEND_URL,BACKEND_URL=$BACKEND_URL,NEXT_PUBLIC_API_BASE_URL=$BACKEND_URL/api" \
            --labels="environment=$ENVIRONMENT,git_ref=${{ needs.determine-environment.outputs.ref_name }},git_sha=$GITHUB_SHA" \
            --project="$GOOGLE_CLOUD_PROJECT"
          echo "‚úÖ Frontend env vars updated"

  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: [determine-environment, configure-routing, deploy-frontend, update-frontend-env]
    if: always() && needs.determine-environment.outputs.deploy == 'true'
    steps:
      - name: Wait for services to be ready
        run: sleep 30
      
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
      
      - name: Perform health checks
        env:
          ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
          SERVICE_SUFFIX: ${{ needs.determine-environment.outputs.service_suffix }}
        run: |
          # Health check all deployed services
          failed_services=()
          for service in api-gateway-fastapi user-service-fastapi order-service-fastapi product-service-fastapi acceptance-service-fastapi notification-service-fastapi customer-hierarchy-service-fastapi supplier-service-fastapi; do
            url=$(gcloud run services describe "orderly-$service-$ENVIRONMENT${SERVICE_SUFFIX}" \
              --region="$GOOGLE_CLOUD_REGION" --format="value(status.url)" \
              --project="$GOOGLE_CLOUD_PROJECT" 2>/dev/null || echo "")
            
            if [ -n "$url" ]; then
              echo "Checking health of $service at $url/health"
              if curl -sf "$url/health" --max-time 30 > /dev/null; then
                echo "‚úÖ $service is healthy"
              else
                echo "‚ùå $service failed health check"
                failed_services+=("$service")
              fi
            else
              echo "‚ö†Ô∏è $service not found or not deployed"
            fi
          done
          
          # Gateway smoke checks (non-auth endpoints)
          gw=$(gcloud run services describe "orderly-api-gateway-fastapi-$ENVIRONMENT" --region="$GOOGLE_CLOUD_REGION" --format="value(status.url)" --project="$GOOGLE_CLOUD_PROJECT" 2>/dev/null || echo "")
          if [ -n "$gw" ]; then
            ENABLE_CID=false
            if [ "$ENVIRONMENT" = "staging" ]; then ENABLE_CID=true; fi
            if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.enable_smoke_correlation }}" = "true" ]; then ENABLE_CID=true; fi

            echo "Gateway smoke: categories"
            resp=$(curl -sS -i -m 30 "$gw/api/products/categories?includeProducts=false" || true)
            code=$(echo "$resp" | sed -n '1p' | awk '{print $2}')
            cid=$(echo "$resp" | sed -n 's/^x-correlation-id:[[:space:]]*\(.*\)$/\1/ip')
            if [ "$ENABLE_CID" = true ]; then
              echo "### Smoke: categories ($code)" >> $GITHUB_STEP_SUMMARY
              echo "X-Correlation-ID: ${cid:-N/A}" >> $GITHUB_STEP_SUMMARY
            fi
            if [ -z "$code" ] || [ "$code" -ge 400 ]; then failed_services+=("gateway-categories"); fi

            echo "Gateway smoke: skus"
            resp=$(curl -sS -i -m 30 "$gw/api/products/skus/search?page_size=1" || true)
            code=$(echo "$resp" | sed -n '1p' | awk '{print $2}')
            cid=$(echo "$resp" | sed -n 's/^x-correlation-id:[[:space:]]*\(.*\)$/\1/ip')
            if [ "$ENABLE_CID" = true ]; then
              echo "### Smoke: skus ($code)" >> $GITHUB_STEP_SUMMARY
              echo "X-Correlation-ID: ${cid:-N/A}" >> $GITHUB_STEP_SUMMARY
            fi
            if [ -z "$code" ] || [ "$code" -ge 400 ]; then failed_services+=("gateway-skus"); fi

            echo "Gateway smoke: hierarchy"
            resp=$(curl -sS -i -m 30 "$gw/api/v2/hierarchy/tree?fast_mode=true" || true)
            code=$(echo "$resp" | sed -n '1p' | awk '{print $2}')
            cid=$(echo "$resp" | sed -n 's/^x-correlation-id:[[:space:]]*\(.*\)$/\1/ip')
            if [ "$ENABLE_CID" = true ]; then
              echo "### Smoke: hierarchy ($code)" >> $GITHUB_STEP_SUMMARY
              echo "X-Correlation-ID: ${cid:-N/A}" >> $GITHUB_STEP_SUMMARY
            fi
            if [ -z "$code" ] || [ "$code" -ge 400 ]; then failed_services+=("gateway-hierarchy"); fi
          fi

          # Service DB health (if endpoint exists)
          prod_url=$(gcloud run services describe "orderly-product-service-fastapi-$ENVIRONMENT" --region="$GOOGLE_CLOUD_REGION" --format="value(status.url)" --project="$GOOGLE_CLOUD_PROJECT" 2>/dev/null || echo "")
          hier_url=$(gcloud run services describe "orderly-customer-hierarchy-service-fastapi-$ENVIRONMENT" --region="$GOOGLE_CLOUD_REGION" --format="value(status.url)" --project="$GOOGLE_CLOUD_PROJECT" 2>/dev/null || echo "")
          if [ -n "$prod_url" ]; then
            echo "DB health: product-service"
            curl -sf "$prod_url/db/health" --max-time 30 > /dev/null || failed_services+=("product-db")
          fi
          if [ -n "$hier_url" ]; then
            echo "DB health: hierarchy-service"
            curl -sf "$hier_url/db/health" --max-time 30 > /dev/null || failed_services+=("hierarchy-db")
          fi

          if [ ${#failed_services[@]} -gt 0 ]; then
            echo "Failed services: ${failed_services[*]}"
            exit 1
          fi
          
          echo "All services are healthy! üéâ"

  post-deployment:
    name: Post-Deployment Tasks
    runs-on: ubuntu-latest
    needs: [determine-environment, health-check, deploy-frontend]
    if: always() && needs.determine-environment.outputs.deploy == 'true'
    steps:
      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
      
      - name: DB diagnostics (Cloud SQL + /db/health)
        env:
          PROJECT_ID: ${{ env.GOOGLE_CLOUD_PROJECT }}
          REGION: ${{ env.GOOGLE_CLOUD_REGION }}
          ENV: ${{ needs.determine-environment.outputs.environment }}
        run: |
          bash scripts/db/diag.sh | tee diag.out
          echo "### DB Diagnostics ($ENV)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          sed 's/^/    /' diag.out >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          # Fail the job if diagnostics found issues
          if grep -Ei '(unreachable|/db/health:\s+http (4|5)[0-9]{2}|POSTGRES_PASSWORD: \(not bound via secret\)|CloudSQL:\s*$|CloudSQL:\s*\(none\))' diag.out; then
            echo "‚ùå DB diagnostics found issues" >&2
            exit 1
          fi

      - name: Create deployment summary
        env:
          ENVIRONMENT: ${{ needs.determine-environment.outputs.environment }}
          HEALTH_CHECK_STATUS: ${{ needs.health-check.result }}
          REF_NAME: ${{ needs.determine-environment.outputs.ref_name }}
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** $ENVIRONMENT" >> $GITHUB_STEP_SUMMARY
          echo "**Ref:** $REF_NAME" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Health Check:** $HEALTH_CHECK_STATUS" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Service URLs:" >> $GITHUB_STEP_SUMMARY
          
          for service in api-gateway-fastapi user-service-fastapi order-service-fastapi product-service-fastapi acceptance-service-fastapi notification-service-fastapi customer-hierarchy-service-fastapi supplier-service-fastapi; do
            url=$(gcloud run services describe "orderly-$service-$ENVIRONMENT" \
              --region="$GOOGLE_CLOUD_REGION" --format="value(status.url)" \
              --project="$GOOGLE_CLOUD_PROJECT" 2>/dev/null || echo "Not deployed")
            echo "- **$service:** $url" >> $GITHUB_STEP_SUMMARY
          done
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Monitoring Links:" >> $GITHUB_STEP_SUMMARY
          echo "- [Cloud Run Console](https://console.cloud.google.com/run?project=$GOOGLE_CLOUD_PROJECT)" >> $GITHUB_STEP_SUMMARY
          echo "- [Cloud SQL Console](https://console.cloud.google.com/sql?project=$GOOGLE_CLOUD_PROJECT)" >> $GITHUB_STEP_SUMMARY
          echo "- [Cloud Logging](https://console.cloud.google.com/logs?project=$GOOGLE_CLOUD_PROJECT)" >> $GITHUB_STEP_SUMMARY
      
      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ needs.health-check.result }}" = "success" ]; then
            echo "üéâ Deployment to ${{ needs.determine-environment.outputs.environment }} completed successfully!"
          else
            echo "‚ùå Deployment to ${{ needs.determine-environment.outputs.environment }} failed!"
          fi
